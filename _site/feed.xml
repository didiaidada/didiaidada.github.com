<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>DanX</title>
    <description></description>
    <link>http://didiaidada.win//</link>
    <atom:link href="http://didiaidada.win//feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Wed, 30 Mar 2016 21:50:44 +0800</pubDate>
    <lastBuildDate>Wed, 30 Mar 2016 21:50:44 +0800</lastBuildDate>
    <generator>Jekyll v3.1.2</generator>
    
      <item>
        <title>ECMAScript6  语法入门</title>
        <description>&lt;p&gt;ECMAScript6是JavaScript的下一代标准。我得了解基本的语法。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;let和const命令&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;JS没有块级作用域，let类似于var，用于声明变量。
不同之处是：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;let声明的变量只在代码块内有效。for循环的计数器很适合let。&lt;/li&gt;
  &lt;li&gt;let没有『变量提升』现象。&lt;/li&gt;
  &lt;li&gt;let在一个作用域内不可重复声明同一个变量。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;const类似于let，不同之处是用于常量的声明并且不可改变。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;变量的解构赋值&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;ES6允许按照一定的模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。
用法解释:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;注意『模式匹配』，即等号两边的模式相同。&lt;/li&gt;
  &lt;li&gt;若解构不成功，变量的值就为undefined。&lt;/li&gt;
  &lt;li&gt;数组元素匹配时，变量的取值由它的位置决定；对象的属性没有次序，变量必须与属性同名，才能取到正确的值。&lt;/li&gt;
  &lt;li&gt;数组和对象的解构都可以指定默认值。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;br&quot;&gt;&lt;br /&gt;&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;字符串的扩展&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;JS内部字符以UTF-16的格式存储，每个字符固定为2个字节。（汉字为4个字节）&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;ES6提供了codePointAt方法，能够正确处理4个字节储存的字符，返回一个字符的码点。ES6提供了String.fromCodePoint方法，可以识别0xFFFF的字符，弥补了String.fromCharCode方法的不足。在作用上，正好与codePointAt方法相反。&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; String.fromCodePoint(0x20BB7) 
 // &quot;吉&quot;
   
var s = &quot;吉a&quot;;
    
s.codePointAt(0) // 134071 即16进制0x20BB7
s.codePointAt(1) // 57271
    
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ES6对正则表达式添加了u修饰符，用来正确处理大于\uFFFF的Unicode字符（可以处理汉字）。&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var s = &quot;吉&quot;;
    
/^.$/.test(s) // false
/^.$/u.test(s) // true
    
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: left&quot;&gt;函数名&lt;/th&gt;
          &lt;th style=&quot;text-align: left&quot;&gt;用法&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;contains()&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;返回布尔值，表示是否找到参数字符串&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;startWith()&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;返回布尔值，表示参数字符串是否在源字符串的头部&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;endWith()&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;返回布尔值，表示参数字符串是否在源字符串的尾部&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;repeat(n)&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;将原字符串重复n次返回&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ES6还为正则表达式添加了y修饰符，叫做“粘连”（sticky）修饰符。&lt;br /&gt;
它的作用与g修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。&lt;br /&gt;
不同之处在于：&lt;br /&gt;
g修饰符只确保剩余位置中存在匹配，而y修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。进一步说，y修饰符号隐含了头部匹配的标志ˆ。ES6的正则对象多了sticky属性，表示是否设置了y修饰符。&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var s = &quot;aaa_aa_a&quot;;
var r1 = /a+/g;
var r2 = /a+/y;
    
r1.exec(s) // [&quot;aaa&quot;]
r2.exec(s) // [&quot;aaa&quot;]
    
r1.exec(s) // [&quot;aa&quot;]
r2.exec(s) // null
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;模板字符串&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;数组的扩展&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;Array.from(),用于将两类伪数组转换为真正的数组，就可以使用数组的方法。&lt;/li&gt;
  &lt;li&gt;Array.of(),用于将一组值转换为数组。&lt;/li&gt;
  &lt;li&gt;find(),数组实例的find()用于找出第一个符合条件的数组元素。它的参数是一个回调函数，所有数组元素依次遍历该回调函数，直到找出第一个返回值为true的元素，然后返回该元素，否则返回undefined。回调函数接受三个参数，依次为当前的值、当前的位置和原数组。&lt;/li&gt;
  &lt;li&gt;findIndex(),与find()用法类似，不同之处是返回的值是第一个符合条件的数组元素的位置，若没有找到则返回-1。&lt;/li&gt;
  &lt;li&gt;fill(n, firstIndex, endIndex),后面两个参数可选，在满足条件的位置用n填充数组。&lt;/li&gt;
  &lt;li&gt;entries()，keys()和values()——用于遍历数组。它们都返回一个遍历器，可以用for…of循环进行遍历，唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。&lt;/li&gt;
  &lt;li&gt;数组推导，ES6提供简洁写法，允许直接通过现有数组生成新数组，这被称为数组推导（array comprehension）。&lt;/li&gt;
  &lt;li&gt;Array.observe()，Array.unobserve()。这两个方法用于监听（取消监听）数组的变化，指定回调函数。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;对象的扩展&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;属性的简洁表示法。ES6允许直接写入变量和函数，作为对象的属性和方法。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Object.is()用来比较两个值是否严格相等。它与严格比较运算符（===）的行为基本一致，不同之处只有两个：一是+0不等于-0，二是NaN等于自身。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Object.assign(target, source1,…),将源对象(source)的所以可枚举属性复制到目标对象(target)。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;proto属性，Object.setPrototypeOf()，Object.getPrototypeOf()&lt;/li&gt;
  &lt;li&gt;ES6引入了一种新的原始数据类型Symbol，表示独一无二的ID。它通过Symbol函数生成。&lt;/li&gt;
  &lt;li&gt;Proxy用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。&lt;/li&gt;
  &lt;li&gt;Object.observe()，Object.unobserve()，用来监听对象（以及数组）的变化。一旦监听对象发生变化，就会触发回调函数。这两个方法不属于ES6，而是属于ES7的一部分。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;函数的扩展&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;函数的参数可以设置默认值&lt;/li&gt;
  &lt;li&gt;ES6引入rest参数(…变量名)，rest参数搭配的变量是一个数组，该变量将多余的参数放入数组中。&lt;/li&gt;
  &lt;li&gt;扩展运算符(…)，它好比rest参数的逆运算。&lt;/li&gt;
  &lt;li&gt;ES6允许使用“箭头”（=&amp;gt;）定义函数。“箭头”前的为函数的输入，“箭头”后为函数的输出。&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    
var f = () =&amp;gt; 5; 
// 等同于
var f = function (){ return 5 };
var sum = (num1, num2) =&amp;gt; num1 + num2;
 // 等同于
var sum = function(num1, num2) {
     return num1 + num2;
};

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Set和Map数据结构&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;ES6提供了新的数据结构Set。它类似于数组，但是成员的值都是唯一的，没有重复。
Set结构有以下属性。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Set.prototype.constructor：构造函数，默认就是Set函数。&lt;/li&gt;
  &lt;li&gt;Set.prototype.size：返回Set的成员总数。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Set数据结构有以下方法。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;add(value)：添加某个值，返回Set结构本身。&lt;/li&gt;
  &lt;li&gt;delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。&lt;/li&gt;
  &lt;li&gt;has(value)：返回一个布尔值，表示该值是否为Set的成员。&lt;/li&gt;
  &lt;li&gt;clear()：清除所有成员，没有返回值。&lt;/li&gt;
  &lt;li&gt;values():返回一个遍历器。&lt;/li&gt;
  &lt;li&gt;foreach(键值，键名，集合本身)：用于对每个成员执行某种操作，返回修改后的Set结构。&lt;/li&gt;
  &lt;li&gt;为了与Map结构保持一致，Set结构也有keys和entries方法，这时每个值的键名就是键值。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;ES6提供了map数据结构，它类似于对象，也是键值对的集合，但“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object结构提供了“字符串—值”的对应，Map结构提供了“值—值”的对应。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;注意，只有对同一个对象的引用，Map结构才将其视为同一个键。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;br /&gt; 
Map数据结构有以下属性和方法。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;size：返回成员总数。&lt;/li&gt;
  &lt;li&gt;set(key, value)：设置key所对应的键值，然后返回整个Map结构。如果key已经有值，则键值会被更新，否则就新生成该键。&lt;/li&gt;
  &lt;li&gt;get(key)：读取key对应的键值，如果找不到key，返回undefined。&lt;/li&gt;
  &lt;li&gt;has(key)：返回一个布尔值，表示某个键是否在Map数据结构中。&lt;/li&gt;
  &lt;li&gt;delete(key)：删除某个键，返回true。如果删除失败，返回false。&lt;/li&gt;
  &lt;li&gt;clear()：清除所有成员，没有返回值。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;
Map原生提供三个遍历器。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;keys()：返回键名的遍历器。&lt;/li&gt;
  &lt;li&gt;values()：返回键值的遍历器。&lt;/li&gt;
  &lt;li&gt;entries()：返回所有成员的遍历器。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Iterator和for…in循环&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;—未完&lt;/p&gt;

</description>
        <pubDate>Wed, 30 Mar 2016 11:32:30 +0800</pubDate>
        <link>http://didiaidada.win//ecmascript6/2016/03/30/ecmascript6%E8%AF%AD%E6%B3%95%E5%85%A5%E9%97%A8.html</link>
        <guid isPermaLink="true">http://didiaidada.win//ecmascript6/2016/03/30/ecmascript6%E8%AF%AD%E6%B3%95%E5%85%A5%E9%97%A8.html</guid>
        
        
        <category>ECMAScript6</category>
        
      </item>
    
      <item>
        <title>跨浏览器的事件处理程序</title>
        <description>&lt;h4 id=&quot;section&quot;&gt;跨浏览器的事件处理程序&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;IE中所有的DOM对象都是以COM（组件对象模型）对象的形式实现，而其他浏览器的DOM对象遵循W3C标准，这意味着IE中的DOM对象与原生Javascript对象的行为或活动特点并不一致。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;dom2&quot;&gt;DOM2级事件处理程序&lt;/h4&gt;

&lt;p&gt;『DOM2级事件』定义了两个方法，用于处理指定和删除事件处理程序的操作：&lt;code class=&quot;highlighter-rouge&quot;&gt;addEventListener()&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;removeEventListener()&lt;/code&gt;，并且它们都接受三个参数：
1. 要处理的事件名
2. 作为事件处理程序的函数
3. 一个布尔值，true - 表示在捕获阶段调用事件处理程序；false - 表示在冒泡阶段调用事件处理程序&lt;/p&gt;

&lt;h4 id=&quot;ieieopera&quot;&gt;IE事件处理程序（IE和Opera）&lt;/h4&gt;

&lt;p&gt;IE实现了与DOM类似的两个方法：&lt;code class=&quot;highlighter-rouge&quot;&gt;attachEvent()&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;detachEvent()&lt;/code&gt;，这两个方法接受两个参数
1. 事件处理程序名称
2. 事件处理程序函数&lt;/p&gt;

&lt;p&gt;DOM的事件对象是&lt;code class=&quot;highlighter-rouge&quot;&gt;event&lt;/code&gt;,IE的事件对象是&lt;code class=&quot;highlighter-rouge&quot;&gt;window.event&lt;/code&gt;。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;EventUtil&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
 
  &lt;span class=&quot;na&quot;&gt;addHandler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;handler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;addEventListener&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;addEventListener&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;handler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
     &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;attachEvent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;attachEvent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;on&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;handler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
     &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;on&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;handler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
     &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; 
  &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;removeHandler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;handler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;removeEventListener&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;removeEventListener&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;handler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
     &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;detachEvent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;detachEvent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;on&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;handler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
     &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;on&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;handler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
     &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;tips-&quot;&gt;tips 使用事件时注意考虑内存与性能方面的问题&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;有必要限制一个页面中的事件处理程序，数量太多回导致占用大量内存，而且也会让用户感觉页面反应不够灵敏&lt;/li&gt;
  &lt;li&gt;建立在事件冒泡机制之上的事件委托技术，可以有效地减少事件处理程序的数量&lt;/li&gt;
  &lt;li&gt;建议在浏览器卸载页面之前移除页面中的所以事件处理程序&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;section-1&quot;&gt;参考&lt;/h4&gt;

&lt;p&gt;『JavaScript高级程序设计』&lt;/p&gt;

</description>
        <pubDate>Sun, 27 Mar 2016 10:10:41 +0800</pubDate>
        <link>http://didiaidada.win//javascript/2016/03/27/%E8%B7%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F.html</link>
        <guid isPermaLink="true">http://didiaidada.win//javascript/2016/03/27/%E8%B7%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F.html</guid>
        
        
        <category>JavaScript</category>
        
      </item>
    
      <item>
        <title>HTML5原生拖放</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;拖放事件最关键的地方确定哪里发生了拖放事件，有哪些事件是在被拖放的元素上触发的，而有哪些事件是在放置目标上触发的&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;section&quot;&gt;推动元素触发的事件&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;dragstart - 按下鼠标时触发该事件&lt;/li&gt;
  &lt;li&gt;drag - 鼠标拖动期间持续触发&lt;/li&gt;
  &lt;li&gt;dragend - 拖动停止是触发&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;被拖动元素被放到一个有效的放置目标上，触发的事件&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;dragenter - 有元素被拖动到放置目标&lt;/li&gt;
  &lt;li&gt;dragover - 被拖动元素在放置目标内移动&lt;/li&gt;
  &lt;li&gt;dragleave或drop - 元素被放到了放置目标中&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;有的元素不支持放置目标事件，需要重写dragenter和dragover的默认事件。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
  &amp;lt;style&amp;gt;
    li{ width:100px; height:30px; border:1px #000000 solid; margin:20px; list-style:none;}
    #div1{ width:100px; height:100px; background:red; margin:300px;}

  &amp;lt;/style&amp;gt;

&amp;lt;ul&amp;gt;
  &amp;lt;li draggable=&quot;true&quot;&amp;gt;dandan&amp;lt;/li&amp;gt;
  &amp;lt;li draggable=&quot;true&quot;&amp;gt;junjun&amp;lt;/li&amp;gt;
  &amp;lt;li draggable=&quot;true&quot;&amp;gt;jenny&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&amp;lt;div id=&quot;div1&quot;&amp;gt;try&amp;lt;/div&amp;gt;
&amp;lt;script&amp;gt;
   var aLi = document.getElementsByTagName(&quot;li&quot;),
       oDiv = document.getElementById(&quot;div1&quot;),
       iNow = 0;



   for(var i=0;i&amp;lt;aLi.length;i++){
     aLi[i].ondragstart = function(){ //拖拽前触发

       this.style.background = &#39;yellow&#39;;

     };

     aLi[i].ondragend = function(){  //拖拽结束触发

       this.style.background = &#39;&#39;;

     };
   }
   oDiv.ondragenter = function(ev){  //相当于onmouseover

     this.style.background = &#39;green&#39;;

     ev.preventDefault();  //阻止默认事件：元素就可以释放了

   };

   oDiv.ondragleave = function(){  //相当于onmouseout

     this.style.background = &#39;red&#39;;

   };

   oDiv.ondragover = function(ev){ //进入目标、离开目标之间，连续触发

     ev.preventDefault();  //阻止默认事件：元素就可以释放了

     document.title = iNow++;

   };

   oDiv.ondrop = function(ev){  //释放鼠标的时候触发

     this.style.background = &#39;red&#39;;

     alert(&quot;鼠标已经释放&quot;);

     ev.preventDefault();  //阻止默认事件：防止打开拖拽元素的url

   };
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;section-2&quot;&gt;参考文献&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/lee_magnum/article/details/17791701&quot;&gt;HTML5实战与剖析之原生拖拽(二拖拽事件dragstart、drag和dragend)&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Sat, 26 Mar 2016 15:51:21 +0800</pubDate>
        <link>http://didiaidada.win//2016/03/26/html5%E7%94%9F%E6%8B%96%E6%8B%BD.html</link>
        <guid isPermaLink="true">http://didiaidada.win//2016/03/26/html5%E7%94%9F%E6%8B%96%E6%8B%BD.html</guid>
        
        <category>JavaScript</category>
        
        
      </item>
    
      <item>
        <title>跨域你知多少</title>
        <description>&lt;h4 id=&quot;section&quot;&gt;什么是跨域？&lt;/h4&gt;

&lt;h4 id=&quot;section-1&quot;&gt;这里的域指的是什么？&lt;/h4&gt;
&lt;p&gt;这里的域指的就是『同源策略』，同源策略限制了一个源（origin）中加载文本或脚本与来自其它源(origin)中资源的交互方式。这两个源必须是同协议，同域名，同端口。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-2&quot;&gt;如何跨域？&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;目前比较推荐的有两种方法：CORS(Cross-Origin Resource Sharing),JSONP
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;cors&quot;&gt;&lt;strong&gt;CORS&lt;/strong&gt;&lt;/h4&gt;
&lt;blockquote&gt;
  &lt;p&gt;跨源资源共享的思想是使用自定义的HTTP头部信息让浏览器与服务器进行沟通，从而决定请求是失败还是成功。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;具体来说，让服务器通过新增响应Access-Control-Allow-Origin，通过HTTP方式来实现资源共享，它使用了HTTP交互方式来确定请求源是否有资格请求该资源，并通过设置HTTP Header来控制访问资源的权限的权限。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//case1:前端发送请求(前端所在的域名http://www.didiaidada.win)
var xhr = new XMLHttpRequest();
xhr.open(&quot;get&quot;,&quot;http://www.baidu.com/dan.json&quot;);
xhr.send();

//如果在服务器端设置HTTP响应头{Access-Control-Allow-Origin:&quot;http://www.baidu.com/&quot;},那么跨域请求成功。就是CORS的一个实现。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;如果要检测XHR是否支持CORS，最简单的方法是检查是否存在withCredentials属性(判断请求中是否有cookie)。&lt;/p&gt;

&lt;h4 id=&quot;jsonp&quot;&gt;&lt;strong&gt;JSONP&lt;/strong&gt;&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;通过jsonp跨域。也就是script标签跨域。script标签可以加载异域的JavaScript并执行，可以通过预先设定好的返回函数和母页面交互。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这个协议的一个要点就是允许用户传递一个callback参数给服务端，然后服务端返回数据时会将这个callback参数作为函数名来包裹住JSON数据。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//原生JS的实现
&amp;lt;script&amp;gt;
var danTest = function(data){
   //可以访问data的相关属性，eg:data.name data.place
}
var url = &quot;http://www.didiaidada.win/json/test.html?callback=danTest&quot;;
var script = document.createElement(&#39;script&#39;);
script.setAttribute(&quot;src&quot;,url);
document.body.insertBefore(script,document.body.firstChild);
&amp;lt;/script&amp;gt;
//jQuery的实现
&amp;lt;script&amp;gt;
$.ajax({
    type: &quot;get&quot;,
    async: false,
    url: &quot;http://www.didiaidada.win/json/test.html&quot;,
    dataType: &quot;jsonp&quot;,
    jsonp: &quot;callback&quot;,//用以获得jsonp回调函数的参数名
    jsonpCallback: &quot;danTest&quot;,//自定义的jsonp回调函数名，默认为jQuery自动生成的随机函数名，也可以是“？”，jQuery会自动处理数据
    success: function(data){
    //可以访问data的相关属性，eg:data.name data.place
    },
    error: function(){
    //处理错误
    }
    });
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;tips&quot;&gt;tips&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;jsonp只能处理get请求，CORS可以处理restful&lt;/li&gt;
  &lt;li&gt;虽然jQuery将jsonp作为ajax的一种进行了封装，但是二者本质上不同。ajax的核心是通过XMLHttpRequest获取非本页内容，而jsonp的核心是动态添加&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;script&amp;gt;&lt;/code&gt;标签来调用服务器提供的js脚本。&lt;/li&gt;
  &lt;li&gt;目前jsonp的应用最广，CORS还存在着浏览器的兼容性问题&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;HTML5新添加的window.postMessage(),window.name,document.domain也都可以一定程度上的实现跨域&lt;/p&gt;

    &lt;p&gt;XDM(cross-document messaging 夸文档消息传递)的核心是postMessage()，这个方法接受两个参数，一条消息和一个表示消息接收方来自哪个域的字符串。
接收到XDM消息时，会触发window对象的message事件。&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//A的域名为“http://www.didiaidada.win”;B的域名为“http://www.baidu.com”,A要向B发送消息
//A的JS代码
window.postMessage(&quot;A secret&quot;,&quot;http://www.baidu.com&quot;);
   
//B的JS代码
EventUtil.addHandler(window,&quot;message&quot;,function(event){
     if(event.origin == &quot;http://www.didiaidada.win&quot;){
         processMessage(event.data);
         event.source.postMessage(&quot;received&quot;,&quot;http://www.didiaidada.win&quot;);
     }
})
   
   
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;section-3&quot;&gt;参考文献&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;http://my.oschina.net/blogshi/blog/303758&quot;&gt;Angular通过CORS实现跨域方案&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000003710973&quot;&gt;浏览器和服务器实现跨域（CORS）判定的原理&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000003710973&quot;&gt;【原创】说说JSON和JSONP，也许你会豁然开朗，含jQuery用例&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Wed, 23 Mar 2016 17:10:43 +0800</pubDate>
        <link>http://didiaidada.win//2016/03/23/%E8%B7%A8%E5%9F%9F%E4%BD%A0%E7%9F%A5%E5%A4%9A%E5%B0%91.html</link>
        <guid isPermaLink="true">http://didiaidada.win//2016/03/23/%E8%B7%A8%E5%9F%9F%E4%BD%A0%E7%9F%A5%E5%A4%9A%E5%B0%91.html</guid>
        
        
      </item>
    
      <item>
        <title>JavaScript设计模式</title>
        <description>&lt;h2 id=&quot;javascript&quot;&gt;JavaScript设计模式简单解释&lt;/h2&gt;

&lt;p&gt; &lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;JS设计模式按照功能可以分为三类：&lt;strong&gt;创建型设计模式&lt;/strong&gt;；&lt;strong&gt;构造型设计模式&lt;/strong&gt;；&lt;strong&gt;行为设计模式&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt; 
1. 创建型设计模式：专注于处理对象的创建机制，以适合给定情况的方式创建对象。主要包括工厂模式，单例模式，构造器模式。
 &lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//工厂模式
function createObject(name, age, profession){
    var obj = new Object();
    obj.name = name;
    obj.age = age;
    obj.profession = profession;
    obj.move = function(){
        return this.name + &#39; at &#39; + this.age + &#39; engaged in &#39; + this.profession;
    };
    return obj;
}


//构造器模式
function Car(model,year,miles){//构造函数模式
        this.model = model;
        this.year = year;
        this.miles = miles;
        this.run = function () {
            return this.model + &quot; has done &quot; + this.miles + &quot;miles&quot;;
        }
    }
 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
 工厂模式用于解决实例化对象大量重复的问题，好处是：可以消除对象之间的耦合，防止代码重复。但是无法识别对象的具体类型。
 构造函数模式解决了重复实例化的问题，又解决了对象识别问题。
&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//单例模式
var single = ( function(){
    var unique;
    function getInstance(){
        if( unique === undefined ){
           unique = new Construct(); 
        }
        reutrn unique;
    }
    function Construct(){
    //生成单例构造函数模式
    }
    return {
        getInstance : getInstance
    }
})();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;
单例模式限制了类的实例化次数只能是一次，在JS中用于划分命名空间。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;构造型设计模式： 与对象组合有关，通常用于找出不同对象之间建立关系的简单方法。主要包括外观模式，适配器模式，代理模式。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;行为设计模式：主要用于改善或简化不同对象之间的通信。主要包括中介者模式，观察者模式。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Mon, 21 Mar 2016 09:42:06 +0800</pubDate>
        <link>http://didiaidada.win//javascript/2016/03/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html</link>
        <guid isPermaLink="true">http://didiaidada.win//javascript/2016/03/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html</guid>
        
        
        <category>JavaScript</category>
        
      </item>
    
      <item>
        <title>Web推送</title>
        <description>&lt;h2 id=&quot;webdata&quot;&gt;Web应用从服务器主动推送Data到客户端有哪些方式&lt;/h2&gt;

&lt;h3 id=&quot;javascript&quot;&gt;JavaScript数据推送&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;commet: 基于HTTP长连接服务器推送技术&lt;/li&gt;
  &lt;li&gt;基于WebSocket的推送方案&lt;/li&gt;
  &lt;li&gt;SSE(Server-Send Event) ：服务器推送数据方式&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 20 Mar 2016 19:51:18 +0800</pubDate>
        <link>http://didiaidada.win//javascript/web/2016/03/20/pull.html</link>
        <guid isPermaLink="true">http://didiaidada.win//javascript/web/2016/03/20/pull.html</guid>
        
        
        <category>JavaScript</category>
        
        <category>Web</category>
        
      </item>
    
      <item>
        <title>my new blog</title>
        <description>&lt;p&gt;终于把我的博客从CSDN上迁出来了，目前是利用Jekyll在github pages上部署。
感触有两点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;利用Bash在Mac上安装Jekyll若遇到问题，要先更新Xcode&lt;/li&gt;
  &lt;li&gt;目前用的博客模板是默认的，接下来会做更改。&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sun, 13 Mar 2016 17:02:42 +0800</pubDate>
        <link>http://didiaidada.win//jekyll/2016/03/13/2016-03-13-new.html</link>
        <guid isPermaLink="true">http://didiaidada.win//jekyll/2016/03/13/2016-03-13-new.html</guid>
        
        
        <category>Jekyll</category>
        
      </item>
    
  </channel>
</rss>
