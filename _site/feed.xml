<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>DanX</title>
    <description></description>
    <link>http://didiaidada.win//</link>
    <atom:link href="http://didiaidada.win//feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Thu, 22 Sep 2016 10:44:28 +0800</pubDate>
    <lastBuildDate>Thu, 22 Sep 2016 10:44:28 +0800</lastBuildDate>
    <generator>Jekyll v3.1.2</generator>
    
      <item>
        <title>JavaScript中的浅拷贝和深拷贝</title>
        <description>&lt;h3 id=&quot;section&quot;&gt;1. 什么是浅拷贝&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;因为JS存储对象都是存地址的,浅拷贝会导致指向同一个地址.简单的赋值就是浅拷贝.因为对象和数组在赋值的时候都是引用传递.赋值的时候只是传递一个指针.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var a = [1,2];
var b = a;
console.log(a); //[1,2]
console.log(b); //[1,2]
b[0] = 2;
console.log(a); //[2,2]
console.log(b); //[2,2]

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-1&quot;&gt;2. 什么是深拷贝&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;深拷贝是开辟一个新的内存地址,将原来对象的各个属性一一复制.&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;3. 实现深拷贝的方法&lt;/h3&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;jquery&quot;&gt;3.1 通过jQuery实现深拷贝&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//$.extend(true, {}, ...)
var x = {
    a: 1,
    b: { f: { g: 1 } },
    c: [ 1, 2, 3 ]
};

var y = $.extend({}, x),          //shallow copy
    z = $.extend(true, {}, x);    //deep copy

y.b.f === x.b.f       // true
z.b.f === x.b.f       // false
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;json&quot;&gt;3.2 借助JSON全局对象&lt;/h4&gt;

&lt;p&gt;它能正确处理的对象只有 Number, String, Boolean, Array, 扁平对象，即那些能够被 json 直接表示的数据结构。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function jsonClone(obj){
    return JSON.parse(JSON.stringify(obj));
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Thu, 22 Sep 2016 09:44:03 +0800</pubDate>
        <link>http://didiaidada.win//2016/09/22/javascript%E4%B8%AD%E7%9A%84%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D.html</link>
        <guid isPermaLink="true">http://didiaidada.win//2016/09/22/javascript%E4%B8%AD%E7%9A%84%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D.html</guid>
        
        
      </item>
    
      <item>
        <title>通过日期倒计时再看Date</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;talk is cheap, show me the code.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function ShowCountDown(year, month, day, divname) {
    var now = new Date();
    var endDate = new Date(year, month - 1, day, 14, 07);
    var leftTime = endDate.getTime() - now.getTime();
    var leftsecond = parseInt(leftTime / 1000);
    var day1 = Math.floor(leftsecond / (60 * 60 * 24));
    var hour1 = Math.floor((leftsecond - day1 * 24 * 60 * 60) / 3600);
    var hour = Math.floor((leftsecond - 60 * 60) / 3600);
    //如果小时为负数 显示0
    if (hour &amp;gt; 0) {
    }
    else {
        hour = 0;
    }
    if (day1 &amp;lt; 0) {
        hour = hour1 ;
    }
    var minute = Math.floor((leftsecond - day1 * 24 * 60 * 60 - hour1 * 3600) / 60);
    var second = Math.floor(leftsecond - day1 * 24 * 60 * 60 - hour1 * 3600 - minute * 60);
    //如果结束时间为负数 就显示0
    if (leftTime &amp;gt; 0) {
        console.log(hour + &quot;小时&quot; + minute + &quot;分&quot; + second + &quot;秒&quot;);
    }
    else {
        console.log(0 + &quot;小时&quot; + 0 + &quot;分&quot; + 0 + &quot;秒&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;blockquote&gt;
  &lt;p&gt;关于JS中Date类型的tips&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;Date.parse()会返回该日期的毫秒数(即从1970-1-1子夜到现在的毫秒数),若传入的数据不能表示日期,则返回NAN.&lt;/li&gt;
  &lt;li&gt;Date.toString()中的月份,采用军用月份,是0-11,例如new Date(2016,2,11),返回的是Fri Mar 11 2016 00:00:00 GMT+0800 (CST)&lt;/li&gt;
  &lt;li&gt;Date.valueOf()返回的不是日期的字符串,而是日期的毫秒数.因此日期可以直接比较大小.&lt;/li&gt;
  &lt;li&gt;Date.now()返回的是当前日期的毫秒数.&lt;/li&gt;
  &lt;li&gt;Date实例拥有的方法getTime(),getFullYear(),getMouth(),getDate(),getMinutes(),getSeconds(),getDay()&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Tue, 20 Sep 2016 09:49:06 +0800</pubDate>
        <link>http://didiaidada.win//javascript/2016/09/20/%E9%80%9A%E8%BF%87%E6%97%A5%E6%9C%9F%E5%80%92%E8%AE%A1%E6%97%B6%E5%86%8D%E7%9C%8BDate.html</link>
        <guid isPermaLink="true">http://didiaidada.win//javascript/2016/09/20/%E9%80%9A%E8%BF%87%E6%97%A5%E6%9C%9F%E5%80%92%E8%AE%A1%E6%97%B6%E5%86%8D%E7%9C%8BDate.html</guid>
        
        
        <category>javascript</category>
        
      </item>
    
      <item>
        <title>ES6入门笔记(二)</title>
        <description>&lt;h3 id=&quot;symbol&quot;&gt;6. Symbol&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt; &lt;/p&gt;

&lt;p&gt;ES6引入了一种新的原始数据类型Symbol，表示独一无二的值。它是JavaScript语言的第七种数据类型，前六种是:Undefined,Null,Boolean,Number,String,Object.&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;p&gt;Symbol函数前不能使用new命令，否则会报错。这是因为生成的Symbol是一个原始类型的值，不是对象。也就是说，由于Symbol值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。&lt;/p&gt;

&lt;p&gt;Symbol函数可以接受一个字符串作为参数，表示对Symbol实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var s1 = Symbol(&#39;foo&#39;);
var s2 = Symbol(&#39;bar&#39;);

s1 // Symbol(foo)
s2 // Symbol(bar)

s1.toString() // &quot;Symbol(foo)&quot;
s2.toString() // &quot;Symbol(bar)&quot;

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Symbol值不能与其他类型的值进行运算，会报错。但是，Symbol值可以显式转为字符串,布尔值.&lt;/p&gt;

&lt;h3 id=&quot;set&quot;&gt;7. Set()&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;ES6提供了新的数据结构Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 去除数组的重复成员
[...new Set(array)]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Set实例的方法分为两大类:操作方法(用于操作数据)和遍历方法（用于遍历成员）.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;操作方法名&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;含义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;add(value)&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;添加某个值,返回Set结构本身&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;delete(value)&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;删除某个值，返回一个布尔值，表示删除是否成功&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;has(value)&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;返回一个布尔值，表示该值是否为Set的成员&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;clear()&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;清除所有成员，没有返回值&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//Array.from方法可以将Set结构转为数组
//去除数组重复成员
function dedupe(array) {
  return Array.from(new Set(array));
}

dedupe([1, 1, 2, 3]) // [1, 2, 3]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;变量方法名&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;含义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;keys()&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;返回键名的遍历器&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;values()&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;返回键值的遍历器&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;entries()&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;返回键值对的遍历器&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;forEach()&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;使用回调函数遍历每个成员&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;由于Set结构没有键名，只有键值（或者说键名和键值是同一个值），所以key方法和value方法的行为完全一致。&lt;/p&gt;

</description>
        <pubDate>Sun, 07 Aug 2016 18:34:53 +0800</pubDate>
        <link>http://didiaidada.win//2016/08/07/es6%E5%85%A5%E9%97%A8%E6%AF%94%E7%AC%94%E8%AE%B0.html</link>
        <guid isPermaLink="true">http://didiaidada.win//2016/08/07/es6%E5%85%A5%E9%97%A8%E6%AF%94%E7%AC%94%E8%AE%B0.html</guid>
        
        
      </item>
    
      <item>
        <title>ES6入门笔记(一)</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;ES6已向我们走来.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;let--const--var&quot;&gt;1. let | const | var&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt; &lt;/p&gt;

&lt;p&gt;let和const是ES6新增的声明变量的方法.&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h4 id=&quot;let&quot;&gt;1.1 let的基本特征&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;let为JavaScript新增块级作用域&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;不存在变量提升&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;暂时性死区,暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if{
    var a = 10;
    let b = 1;
}

a // ReferenceError: a is not defined.
b // 1
//暂时性死区
var tmp = 123;

if (true) {
  tmp = &#39;abc&#39;; // ReferenceError
  let tmp;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;const&quot;&gt;1.2 const基本特征&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;const声明一个只读的常量。一旦声明，常量的值就不能改变.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;对const来说,只声明不赋值,会报错.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;const的作用域与let命令相同：只在声明所在的块级作用域内有效.const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const foo;
// SyntaxError: Missing initializer in const declaration

//块级作用域
if (true) {
  const MAX = 5;
}
MAX // Uncaught ReferenceError: MAX is not defined

//变量不提升
if (true) {
  console.log(MAX); // ReferenceError
  const MAX = 5;
}


&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;letconst&quot;&gt;1.3 let和const其他特征&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;ES5中未声明的全局变量,会自动成为window对象的属性.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;var命令和function命令声明的全局变量，依旧是全局对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于全局对象的属性.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var a = 1;
// 如果在Node的REPL环境，可以写成global.a
// 或者采用通用方法，写成this.a
window.a // 1

let b = 1;
window.b // undefined

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section&quot;&gt;2. 变量的解构赋值&lt;/h3&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-1&quot;&gt;3. 字符串的扩展&lt;/h3&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;section-2&quot;&gt;3.1 新增的实用方法&lt;/h4&gt;

&lt;p&gt;传统上，JavaScript只有indexOf方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6又提供了三种新方法。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;函数名&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;用法&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;includes()&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;返回布尔值,表示是否找到参数字符串&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;startsWith()&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;返回布尔值,表示参数字符串是否在源字符串的头部&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;endsWidth()&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;返回布尔值,表示参数字符串是否在源字符串的尾部&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;repeat()&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;返回一个新字符串,表示将源字符串重复n次&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;section-3&quot;&gt;3.2 模板字符串&lt;/h4&gt;

&lt;p&gt;模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
// 普通字符串
`In JavaScript &#39;\n&#39; is a line-feed.`

// 多行字符串
`In JavaScript this is
 not legal.`

console.log(`string text line 1
string text line 2`);

// 字符串中嵌入变量
var name = &quot;Bob&quot;, time = &quot;today&quot;;
`Hello ${name}, how are you ${time}?`

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-4&quot;&gt;4. 函数的扩展&lt;/h3&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;section-5&quot;&gt;4.1 箭头函数&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;注意:函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;箭头函数可以让this指向固定化，这种特性很有利于封装回调函数。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function Timer() {
  this.s1 = 0;
  this.s2 = 0;
  // 箭头函数
  setInterval(() =&amp;gt; this.s1++, 1000);
  // 普通函数
  setInterval(function () {
    this.s2++;
  }, 1000);
}

var timer = new Timer();

setTimeout(() =&amp;gt; console.log(&#39;s1: &#39;, timer.s1), 3100);
setTimeout(() =&amp;gt; console.log(&#39;s2: &#39;, timer.s2), 3100);
// s1: 3
// s2: 0

//上面代码中，Timer函数内部设置了两个定时器，分别使用了箭头函数和普通函数。前者的this绑定定义时所在的作用域（即Timer函数），后者的this指向运行时所在的作用域（即全局对象）。所以，3100毫秒之后，timer.s1被更新了3次，而timer.s2一次都没更新。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-6&quot;&gt;5. 对象的扩展&lt;/h3&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;section-7&quot;&gt;5.1 属性的简洁表示法&lt;/h4&gt;

&lt;p&gt;ES6允许直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function f(x, y) {
  return {x, y};
}

// 等同于

function f(x, y) {
  return {x: x, y: y};
}

f(1, 2) // Object {x: 1, y: 2}


var o = {
  method() {
    return &quot;Hello!&quot;;
  }
};

// 等同于

var o = {
  method: function() {
    return &quot;Hello!&quot;;
  }
};

var birth = &#39;2000/01/01&#39;;

var Person = {

  name: &#39;张三&#39;,

  //等同于birth: birth
  birth,

  // 等同于hello: function ()...
  hello() { console.log(&#39;我的名字是&#39;, this.name); }

};
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-8&quot;&gt;5.2 属性名表达式&lt;/h4&gt;

&lt;p&gt;对象的属性可以使用表达式&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h4 id=&quot;name&quot;&gt;5.3 方法的name属性&lt;/h4&gt;

&lt;p&gt;函数的name属性，返回函数名。对象方法也是函数，因此也有name属性。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h4 id=&quot;objectis&quot;&gt;5.4 Object.is()&lt;/h4&gt;

&lt;p&gt;ES5比较两个值是否相等，只有两个运算符：相等运算符（==）和严格相等运算符（===）。它们都有缺点，前者会自动转换数据类型，后者的NaN不等于自身，以及+0等于-0。&lt;/p&gt;

&lt;p&gt;Object.is就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。不同之处只有两个：一是+0不等于-0，二是NaN等于自身。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h4 id=&quot;objectassign&quot;&gt;5.5 Object.assign()&lt;/h4&gt;

&lt;p&gt;Object.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//Object.assign方法的第一个参数是目标对象，后面的参数都是源对象。

var target = { a: 1 };

var source1 = { b: 2 };
var source2 = { c: 3 };

Object.assign(target, source1, source2);
target // {a:1, b:2, c:3}

//如果该参数不是对象，则会先转成对象，然后返回。
//由于undefined和null无法转成对象，所以如果它们作为参数，就会报错。

typeof Object.assign(2) // &quot;object&quot;
Object.assign(undefined) // 报错
Object.assign(null) // 报错


&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Object.assign方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。&lt;/p&gt;

</description>
        <pubDate>Wed, 03 Aug 2016 19:01:41 +0800</pubDate>
        <link>http://didiaidada.win//es6/2016/08/03/es6%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0.html</link>
        <guid isPermaLink="true">http://didiaidada.win//es6/2016/08/03/es6%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0.html</guid>
        
        <category>ES6</category>
        
        
        <category>ES6</category>
        
      </item>
    
      <item>
        <title>css secrects which i should know</title>
        <description>&lt;h4 id=&quot;css-secrets&quot;&gt;「css secrets」的评价很高,写这本书的也是一位很出色的女生.向她学习.我也想借着学习的过程修改下我博客的样式.&lt;/h4&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section&quot;&gt;背景与边框&lt;/h3&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;px em rem&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;px (pixel),像素,相对于显示器屏幕分辨率而言.相对于浏览器它的值是固定的.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Em 和 rem都是灵活,可扩展的单位,由浏览器转换为像素值,具体取决于设计中的字体大小设置.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;em单位基于使用他们的元素的字体大小.rem单位基于html元素的字体大小.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;em单位可能受任何继承的父元素字体大小影响.rem单位可以从浏览器字体设置中继承字体大小.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;任意浏览器的默认字体高都是16px.所有未经调整的浏览器都符合: 1em=16px.(1px - 0.05em)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;HSLA(H,S,L,A)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;H: Hue(色调).0(或360)表示红色,120表示绿色,240表示蓝色,也可取其他数值来指定颜色.取值为：0 - 360&lt;/p&gt;

&lt;p&gt;S: Saturation(饱和度).取值为:0.0% - 100.0%&lt;/p&gt;

&lt;p&gt;L: Lightness(亮度).取值为:0.0% - 100.0%&lt;/p&gt;

&lt;p&gt;A: Alpha透明度.取值0~1之间&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;table&gt;
    &lt;tbody&gt;
      &lt;tr&gt;
        &lt;td&gt;background-clip:border-box&lt;/td&gt;
        &lt;td&gt;padding-box&lt;/td&gt;
        &lt;td&gt;content-box;属性规定背景的绘制区域.&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/tbody&gt;
  &lt;/table&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;box-shadow:h-shadow v-shadow blur spread color inset;向框添加一个或多个阴影.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;cal() 四则运算用于动态计算长度值&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;条纹背景&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;linear-gradient 常用于产生水平或者垂直条纹. repeating-linear-gradient 常用于制作斜条纹.&lt;/li&gt;
  &lt;li&gt;linear-gradient 叠加可以制作网格.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;波点&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;radial-gradient&lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Tue, 26 Apr 2016 09:34:13 +0800</pubDate>
        <link>http://didiaidada.win//css/2016/04/26/CSS%E6%8F%AD%E7%A7%98%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B8%80%E8%83%8C%E6%99%AF%E4%B8%8E%E8%BE%B9%E6%A1%86.html</link>
        <guid isPermaLink="true">http://didiaidada.win//css/2016/04/26/CSS%E6%8F%AD%E7%A7%98%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B8%80%E8%83%8C%E6%99%AF%E4%B8%8E%E8%BE%B9%E6%A1%86.html</guid>
        
        
        <category>css</category>
        
      </item>
    
      <item>
        <title>Baidu网页搜索部实习面试</title>
        <description>&lt;p&gt;面试从一点半到四点半,当时不觉得累,回到学校很累.面试的体验感觉不错.一共三面,前两面是技术面,最后一面是项目经理面.面试有条理,有梯度,考察的技术知识比较广.第三面的面试官说我太注重技术了.工作的完成依赖于技术,但还有很多其他的软实力吧,我现在还不是很能理解.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;question1---node&quot;&gt;QUESTION1 - Node常用的原生核心模&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;util提供常用函数的集合,用于弥补原生JS的功能过于精简不足.&lt;/li&gt;
  &lt;li&gt;事件驱动events,并且这个模块只有一个对象:events.EventEmitter.EventEmitter的核心就是事件发射与事件监听器封装的功能.&lt;/li&gt;
  &lt;li&gt;fs是文件操作的封装,它提供了文件的读取,写入,更名,删除,遍历目录,链接等POSIX文件操作系统.&lt;/li&gt;
  &lt;li&gt;http模块.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;question2---js&quot;&gt;QUESTION2 - 清除JS缓存&lt;/h4&gt;

&lt;p&gt;方法一: mate方法&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;META HTTP-EQUIV=&quot;pragma&quot; CONTENT=&quot;no-cache&quot;&amp;gt;
&amp;lt;META HTTP-EQUIV=&quot;Cache-Control&quot; CONTENT=&quot;no-cache&quot;&amp;gt;
&amp;lt;META HTTP-EQUIV=&quot;expires&quot; CONTENT=&quot;0&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;方法二: ajax直接用cache:false&lt;/p&gt;

&lt;p&gt;方法三: 用随机数避免缓存,&lt;code class=&quot;highlighter-rouge&quot;&gt;location.href = location.href + &quot;?_=&quot; + new Date().valueOf()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;question3---http&quot;&gt;QUESTION3 - HTTP协议详解&lt;/h4&gt;

&lt;p&gt;HTTP是一个客户端（用户）和服务器端（网站）请求和答应的标准.通过Web浏览器,网络爬虫或者其他的工具,客户端发起一个HTTP请求到服务器上指定端口（默认端口为80）.http（超文本传输协议）是一个基于请求与响应模式的、无状态的、应用层的协议.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;HTTP的主要特点是:&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;支持客户/服务器模式&lt;/li&gt;
  &lt;li&gt;简单快速&lt;/li&gt;
  &lt;li&gt;灵活,HTTP允许传输任意类型的数据对象&lt;/li&gt;
  &lt;li&gt;无连接,无连接的含义是限制每次连接只处理一个请求.服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。&lt;/li&gt;
  &lt;li&gt;无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;HTTP请求由三个部分组成,分别是:请求行,消息报头,请求正文&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;请求行以一个方法符号开头，以空格分开，后面跟着请求的URI和协议的版本，格式如下：
    &lt;ul&gt;
      &lt;li&gt;请求的方法有8种,常用的有GET,POST,HEAD,PUT,DELETE,TRACE,CONNECT,OPTIONS&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;HTTP响应由三个部分组成,分别是:状态行,消息报头,响应正文&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;状态行的格式&lt;code class=&quot;highlighter-rouge&quot;&gt;HTTP-Version Status-Code Reason-Phrase CRLF&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
//xhr.status

1xx：指示信息--表示请求已接收，继续处理
2xx：成功--表示请求已被成功接收、理解、接受
3xx：重定向--要完成请求必须进行更进一步的操作
4xx：客户端错误--请求有语法错误或请求无法实现
5xx：服务器端错误--服务器未能实现合法的请求

//常见的状态码

200 OK  //客户端请求成功
400 Bad Request  //客户端请求有语法错误，不能被服务器所理解
401 Unauthorized //请求未经授权，这个状态代码必须和WWW-Authenticate报 //头域一起使用
403 Forbidden  //服务器收到请求，但是拒绝提供服务
404 Not Found  //请求资源不存在，eg：输入了错误的URL
500 Internal Server Error //服务器发生不可预期的错误
503 Server Unavailable  //服务器当前不能处理客户端的请求，一段时间后,可能恢复正常

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;请求报头&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;报头解释&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Accept&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;用于指定客户端接受哪些类型的信息&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Accept-Charset&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;用于指定客户端接受的字符集&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Accept-Encoding&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;用于指定可接受的内容编码&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Accept-Language&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;用于指定客户端可接受的自然语言&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Authorization      &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;用于证明客户端有权查看某个资源。当浏览器访问一个页面时，如果收到服务器的响应代码为401（未授权），可以发送一个包含Authorization请求报头域的请求，要求服务器对其进行验证&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Host&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;指定被请求资源的Internet主机和端口号（必需项）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;User-Agent&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;请求报头域允许客户端将它的操作系统、浏览器和其它属性告诉服务器&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;section&quot;&gt;参考&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;http://www.jianshu.com/p/e83d323c6bcc&quot;&gt;Http协议详解&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Thu, 07 Apr 2016 20:28:29 +0800</pubDate>
        <link>http://didiaidada.win//%E9%9D%A2%E8%AF%95/2016/04/07/baidu%E7%BD%91%E9%A1%B5%E6%90%9C%E7%B4%A2%E9%83%A8%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95.html</link>
        <guid isPermaLink="true">http://didiaidada.win//%E9%9D%A2%E8%AF%95/2016/04/07/baidu%E7%BD%91%E9%A1%B5%E6%90%9C%E7%B4%A2%E9%83%A8%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95.html</guid>
        
        
        <category>面试</category>
        
      </item>
    
      <item>
        <title>前端实习面试 小猿</title>
        <description>&lt;h4 id=&quot;section&quot;&gt;小米&lt;/h4&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;面的是小米UI黄页组,很突然4月1号早上给我打电话,然后下午就过去了,甚至没有邮件~~~&lt;/p&gt;

&lt;p&gt;问得东西很基础,我就说说我没答上的部分&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;宽高不固定的元素如何居中&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;宽度不固定,水平居中&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//父容器 text-align:center;
//子容器 display:inline-block;

.container{width:500px;height:80px;background:#C2300B;margin-left:50px;padding-top:10px;text-align:center;}
.center{display:inline-block;border:2px solid #fff;}
.center{_display:inline;} /*针对ie6 hack*/
.center a{float:left;border:1px solid #fff;padding:5px 10px;margin:10px;color:#fff;text-decoration:none;}
 &amp;lt;div class=&quot;container&quot;&amp;gt;
     &amp;lt;div class=&quot;center&quot;&amp;gt;&amp;lt;a href=&quot;#&quot;&amp;gt;1&amp;lt;/a&amp;gt;&amp;lt;a href=&quot;#&quot;&amp;gt;2&amp;lt;/a&amp;gt;&amp;lt;a href=&quot;#&quot;&amp;gt;3&amp;lt;/a&amp;gt;&amp;lt;a href=&quot;#&quot;&amp;gt;4&amp;lt;/a&amp;gt;
         &amp;lt;div style=&quot;clear:both&quot;&amp;gt;&amp;lt;/div&amp;gt;
     &amp;lt;/div&amp;gt;
 &amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;高度不固定,垂直居中&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//父容器 display:table;overflow:hidden;
//子容器 display:table-cell;vertical-align:middle;

#vc { display:table; background-color:#C2300B; width:500px; height:200px; overflow:hidden; margin-left:50px; _position:relative; }
#vci { vertical-align:middle; display:table-cell; text-align:center; _position:absolute; _top:50%; _left:50%; }
#content { color:#fff; border:1px solid #fff; display:inline-block; _position:relative; _top:-50%; _left:-50%; }
&amp;lt;div id=&quot;vc&quot;&amp;gt;
    &amp;lt;div id=&quot;vci&quot;&amp;gt;
        &amp;lt;div id=&quot;content&quot;&amp;gt;
    我们垂直居中了，我们水平居中了
        &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;CSS3使用flex布局&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#parent {
            display: flex;
            width: 400px; /* 宽度值，随便啦 */
            height: 400px;  /* 高度值，随便啦 */
            background-color: yellow;
        }

#item {
            width: 100px;/* 宽度值，随便啦 */
            height: 20px;/* 高度值，随便啦 */
            margin: auto;
            background-color: red; /* Magic! */
        }

&amp;lt;div id=&quot;parent&quot;&amp;gt;
    &amp;lt;div id=&quot;item&quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;tips: &lt;strong&gt;flex box&lt;/strong&gt;
猿题库也问了我这个,我当时答的不好,可以参考&lt;a href=&quot;http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html&quot;&gt;这个讲解&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;事件委托&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;使用事件委托技术能让你避免对特定的每个节点添加事件监听器；相反，事件监听器是被添加到它们的父元素上。事件监听器会分析从子元素冒泡上来的事件，找到是哪个子元素的事件。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;ul id=&quot;list&quot;&amp;gt;
  &amp;lt;li id=&quot;item1&quot;&amp;gt;item1&amp;lt;/li&amp;gt;
  &amp;lt;li id=&quot;item2&quot;&amp;gt;item2&amp;lt;/li&amp;gt;
  &amp;lt;li id=&quot;item3&quot;&amp;gt;item3&amp;lt;/li&amp;gt;
  &amp;lt;li id=&quot;item4&quot;&amp;gt;item4&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;

window.onload=function(){
  var ulNode=document.getElementById(&quot;list&quot;);
  ulNode.addEventListener(&#39;click&#39;,function(e){
       if(e.target&amp;amp;&amp;amp;e.target.nodeName.toUpperCase()==&quot;LI&quot;){/*判断目标事件是否为li*/
         alert(e.target.innerHTML);
       }
     },false);

};

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Sun, 03 Apr 2016 21:12:28 +0800</pubDate>
        <link>http://didiaidada.win//2016/04/03/%E5%89%8D%E7%AB%AF%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95-%E5%B0%8F%E7%8C%BF.html</link>
        <guid isPermaLink="true">http://didiaidada.win//2016/04/03/%E5%89%8D%E7%AB%AF%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95-%E5%B0%8F%E7%8C%BF.html</guid>
        
        
      </item>
    
      <item>
        <title>ECMAScript6  语法入门</title>
        <description>&lt;p&gt;ECMAScript6是JavaScript的下一代标准。我得了解基本的语法。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;let和const命令&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;JS没有块级作用域，let类似于var，用于声明变量。
不同之处是：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;let声明的变量只在代码块内有效。for循环的计数器很适合let。&lt;/li&gt;
  &lt;li&gt;let没有『变量提升』现象。&lt;/li&gt;
  &lt;li&gt;let在一个作用域内不可重复声明同一个变量。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;const类似于let，不同之处是用于常量的声明并且不可改变。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;变量的解构赋值&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;ES6允许按照一定的模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。
用法解释:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;注意『模式匹配』，即等号两边的模式相同。&lt;/li&gt;
  &lt;li&gt;若解构不成功，变量的值就为undefined。&lt;/li&gt;
  &lt;li&gt;数组元素匹配时，变量的取值由它的位置决定；对象的属性没有次序，变量必须与属性同名，才能取到正确的值。&lt;/li&gt;
  &lt;li&gt;数组和对象的解构都可以指定默认值。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;br&quot;&gt;&lt;br /&gt;&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;字符串的扩展&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;JS内部字符以UTF-16的格式存储，每个字符固定为2个字节。（汉字为4个字节）&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;ES6提供了codePointAt方法，能够正确处理4个字节储存的字符，返回一个字符的码点。ES6提供了String.fromCodePoint方法，可以识别0xFFFF的字符，弥补了String.fromCharCode方法的不足。在作用上，正好与codePointAt方法相反。&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; String.fromCodePoint(0x20BB7) 
 // &quot;吉&quot;
   
var s = &quot;吉a&quot;;
    
s.codePointAt(0) // 134071 即16进制0x20BB7
s.codePointAt(1) // 57271
    
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ES6对正则表达式添加了u修饰符，用来正确处理大于\uFFFF的Unicode字符（可以处理汉字）。&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var s = &quot;吉&quot;;
    
/^.$/.test(s) // false
/^.$/u.test(s) // true
    
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: left&quot;&gt;函数名&lt;/th&gt;
          &lt;th style=&quot;text-align: left&quot;&gt;用法&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;contains()&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;返回布尔值，表示是否找到参数字符串&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;startWith()&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;返回布尔值，表示参数字符串是否在源字符串的头部&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;endWith()&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;返回布尔值，表示参数字符串是否在源字符串的尾部&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;repeat(n)&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;将原字符串重复n次返回&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ES6还为正则表达式添加了y修饰符，叫做“粘连”（sticky）修饰符。&lt;br /&gt;
它的作用与g修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。&lt;br /&gt;
不同之处在于：&lt;br /&gt;
g修饰符只确保剩余位置中存在匹配，而y修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。进一步说，y修饰符号隐含了头部匹配的标志ˆ。ES6的正则对象多了sticky属性，表示是否设置了y修饰符。&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var s = &quot;aaa_aa_a&quot;;
var r1 = /a+/g;
var r2 = /a+/y;
    
r1.exec(s) // [&quot;aaa&quot;]
r2.exec(s) // [&quot;aaa&quot;]
    
r1.exec(s) // [&quot;aa&quot;]
r2.exec(s) // null
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;模板字符串&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;数组的扩展&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;Array.from(),用于将两类伪数组转换为真正的数组，就可以使用数组的方法。&lt;/li&gt;
  &lt;li&gt;Array.of(),用于将一组值转换为数组。&lt;/li&gt;
  &lt;li&gt;find(),数组实例的find()用于找出第一个符合条件的数组元素。它的参数是一个回调函数，所有数组元素依次遍历该回调函数，直到找出第一个返回值为true的元素，然后返回该元素，否则返回undefined。回调函数接受三个参数，依次为当前的值、当前的位置和原数组。&lt;/li&gt;
  &lt;li&gt;findIndex(),与find()用法类似，不同之处是返回的值是第一个符合条件的数组元素的位置，若没有找到则返回-1。&lt;/li&gt;
  &lt;li&gt;fill(n, firstIndex, endIndex),后面两个参数可选，在满足条件的位置用n填充数组。&lt;/li&gt;
  &lt;li&gt;entries()，keys()和values()——用于遍历数组。它们都返回一个遍历器，可以用for…of循环进行遍历，唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。&lt;/li&gt;
  &lt;li&gt;数组推导，ES6提供简洁写法，允许直接通过现有数组生成新数组，这被称为数组推导（array comprehension）。&lt;/li&gt;
  &lt;li&gt;Array.observe()，Array.unobserve()。这两个方法用于监听（取消监听）数组的变化，指定回调函数。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;对象的扩展&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;属性的简洁表示法。ES6允许直接写入变量和函数，作为对象的属性和方法。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Object.is()用来比较两个值是否严格相等。它与严格比较运算符（===）的行为基本一致，不同之处只有两个：一是+0不等于-0，二是NaN等于自身。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Object.assign(target, source1,…),将源对象(source)的所以可枚举属性复制到目标对象(target)。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;proto属性，Object.setPrototypeOf()，Object.getPrototypeOf()&lt;/li&gt;
  &lt;li&gt;ES6引入了一种新的原始数据类型Symbol，表示独一无二的ID。它通过Symbol函数生成。&lt;/li&gt;
  &lt;li&gt;Proxy用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。&lt;/li&gt;
  &lt;li&gt;Object.observe()，Object.unobserve()，用来监听对象（以及数组）的变化。一旦监听对象发生变化，就会触发回调函数。这两个方法不属于ES6，而是属于ES7的一部分。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;函数的扩展&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;函数的参数可以设置默认值&lt;/li&gt;
  &lt;li&gt;ES6引入rest参数(…变量名)，rest参数搭配的变量是一个数组，该变量将多余的参数放入数组中。&lt;/li&gt;
  &lt;li&gt;扩展运算符(…)，它好比rest参数的逆运算。&lt;/li&gt;
  &lt;li&gt;ES6允许使用“箭头”（=&amp;gt;）定义函数。“箭头”前的为函数的输入，“箭头”后为函数的输出。&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    
var f = () =&amp;gt; 5; 
// 等同于
var f = function (){ return 5 };
var sum = (num1, num2) =&amp;gt; num1 + num2;
 // 等同于
var sum = function(num1, num2) {
     return num1 + num2;
};

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Set和Map数据结构&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;ES6提供了新的数据结构Set。它类似于数组，但是成员的值都是唯一的，没有重复。
Set结构有以下属性。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Set.prototype.constructor：构造函数，默认就是Set函数。&lt;/li&gt;
  &lt;li&gt;Set.prototype.size：返回Set的成员总数。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Set数据结构有以下方法。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;add(value)：添加某个值，返回Set结构本身。&lt;/li&gt;
  &lt;li&gt;delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。&lt;/li&gt;
  &lt;li&gt;has(value)：返回一个布尔值，表示该值是否为Set的成员。&lt;/li&gt;
  &lt;li&gt;clear()：清除所有成员，没有返回值。&lt;/li&gt;
  &lt;li&gt;values():返回一个遍历器。&lt;/li&gt;
  &lt;li&gt;foreach(键值，键名，集合本身)：用于对每个成员执行某种操作，返回修改后的Set结构。&lt;/li&gt;
  &lt;li&gt;为了与Map结构保持一致，Set结构也有keys和entries方法，这时每个值的键名就是键值。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;ES6提供了map数据结构，它类似于对象，也是键值对的集合，但“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object结构提供了“字符串—值”的对应，Map结构提供了“值—值”的对应。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;注意，只有对同一个对象的引用，Map结构才将其视为同一个键。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;br /&gt; 
Map数据结构有以下属性和方法。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;size：返回成员总数。&lt;/li&gt;
  &lt;li&gt;set(key, value)：设置key所对应的键值，然后返回整个Map结构。如果key已经有值，则键值会被更新，否则就新生成该键。&lt;/li&gt;
  &lt;li&gt;get(key)：读取key对应的键值，如果找不到key，返回undefined。&lt;/li&gt;
  &lt;li&gt;has(key)：返回一个布尔值，表示某个键是否在Map数据结构中。&lt;/li&gt;
  &lt;li&gt;delete(key)：删除某个键，返回true。如果删除失败，返回false。&lt;/li&gt;
  &lt;li&gt;clear()：清除所有成员，没有返回值。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;
Map原生提供三个遍历器。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;keys()：返回键名的遍历器。&lt;/li&gt;
  &lt;li&gt;values()：返回键值的遍历器。&lt;/li&gt;
  &lt;li&gt;entries()：返回所有成员的遍历器。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Iterator和for…in循环&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;—未完&lt;/p&gt;

</description>
        <pubDate>Wed, 30 Mar 2016 11:32:30 +0800</pubDate>
        <link>http://didiaidada.win//ecmascript6/2016/03/30/ecmascript6%E8%AF%AD%E6%B3%95%E5%85%A5%E9%97%A8.html</link>
        <guid isPermaLink="true">http://didiaidada.win//ecmascript6/2016/03/30/ecmascript6%E8%AF%AD%E6%B3%95%E5%85%A5%E9%97%A8.html</guid>
        
        
        <category>ECMAScript6</category>
        
      </item>
    
      <item>
        <title>跨浏览器的事件处理程序</title>
        <description>&lt;h4 id=&quot;section&quot;&gt;跨浏览器的事件处理程序&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;IE中所有的DOM对象都是以COM（组件对象模型）对象的形式实现，而其他浏览器的DOM对象遵循W3C标准，这意味着IE中的DOM对象与原生Javascript对象的行为或活动特点并不一致。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;dom2&quot;&gt;DOM2级事件处理程序&lt;/h4&gt;

&lt;p&gt;『DOM2级事件』定义了两个方法，用于处理指定和删除事件处理程序的操作：&lt;code class=&quot;highlighter-rouge&quot;&gt;addEventListener()&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;removeEventListener()&lt;/code&gt;，并且它们都接受三个参数：
1. 要处理的事件名
2. 作为事件处理程序的函数
3. 一个布尔值，true - 表示在捕获阶段调用事件处理程序；false - 表示在冒泡阶段调用事件处理程序&lt;/p&gt;

&lt;h4 id=&quot;ieieopera&quot;&gt;IE事件处理程序（IE和Opera）&lt;/h4&gt;

&lt;p&gt;IE实现了与DOM类似的两个方法：&lt;code class=&quot;highlighter-rouge&quot;&gt;attachEvent()&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;detachEvent()&lt;/code&gt;，这两个方法接受两个参数
1. 事件处理程序名称
2. 事件处理程序函数&lt;/p&gt;

&lt;p&gt;DOM的事件对象是&lt;code class=&quot;highlighter-rouge&quot;&gt;event&lt;/code&gt;,IE的事件对象是&lt;code class=&quot;highlighter-rouge&quot;&gt;window.event&lt;/code&gt;。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;EventUtil&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
 
  &lt;span class=&quot;na&quot;&gt;addHandler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;handler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;addEventListener&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;addEventListener&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;handler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
     &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;attachEvent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;attachEvent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;on&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;handler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
     &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;on&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;handler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
     &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; 
  &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;removeHandler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;handler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;removeEventListener&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;removeEventListener&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;handler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
     &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;detachEvent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;detachEvent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;on&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;handler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
     &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;on&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;handler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
     &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;tips-&quot;&gt;tips 使用事件时注意考虑内存与性能方面的问题&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;有必要限制一个页面中的事件处理程序，数量太多回导致占用大量内存，而且也会让用户感觉页面反应不够灵敏&lt;/li&gt;
  &lt;li&gt;建立在事件冒泡机制之上的事件委托技术，可以有效地减少事件处理程序的数量&lt;/li&gt;
  &lt;li&gt;建议在浏览器卸载页面之前移除页面中的所以事件处理程序&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;section-1&quot;&gt;参考&lt;/h4&gt;

&lt;p&gt;『JavaScript高级程序设计』&lt;/p&gt;

</description>
        <pubDate>Sun, 27 Mar 2016 10:10:41 +0800</pubDate>
        <link>http://didiaidada.win//javascript/2016/03/27/%E8%B7%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F.html</link>
        <guid isPermaLink="true">http://didiaidada.win//javascript/2016/03/27/%E8%B7%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F.html</guid>
        
        
        <category>JavaScript</category>
        
      </item>
    
      <item>
        <title>HTML5原生拖放</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;拖放事件最关键的地方确定哪里发生了拖放事件，有哪些事件是在被拖放的元素上触发的，而有哪些事件是在放置目标上触发的&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;section&quot;&gt;推动元素触发的事件&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;dragstart - 按下鼠标时触发该事件&lt;/li&gt;
  &lt;li&gt;drag - 鼠标拖动期间持续触发&lt;/li&gt;
  &lt;li&gt;dragend - 拖动停止是触发&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;被拖动元素被放到一个有效的放置目标上，触发的事件&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;dragenter - 有元素被拖动到放置目标&lt;/li&gt;
  &lt;li&gt;dragover - 被拖动元素在放置目标内移动&lt;/li&gt;
  &lt;li&gt;dragleave或drop - 元素被放到了放置目标中&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;有的元素不支持放置目标事件，需要重写dragenter和dragover的默认事件。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
  &amp;lt;style&amp;gt;
    li{ width:100px; height:30px; border:1px #000000 solid; margin:20px; list-style:none;}
    #div1{ width:100px; height:100px; background:red; margin:300px;}

  &amp;lt;/style&amp;gt;

&amp;lt;ul&amp;gt;
  &amp;lt;li draggable=&quot;true&quot;&amp;gt;dandan&amp;lt;/li&amp;gt;
  &amp;lt;li draggable=&quot;true&quot;&amp;gt;junjun&amp;lt;/li&amp;gt;
  &amp;lt;li draggable=&quot;true&quot;&amp;gt;jenny&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&amp;lt;div id=&quot;div1&quot;&amp;gt;try&amp;lt;/div&amp;gt;
&amp;lt;script&amp;gt;
   var aLi = document.getElementsByTagName(&quot;li&quot;),
       oDiv = document.getElementById(&quot;div1&quot;),
       iNow = 0;



   for(var i=0;i&amp;lt;aLi.length;i++){
     aLi[i].ondragstart = function(){ //拖拽前触发

       this.style.background = &#39;yellow&#39;;

     };

     aLi[i].ondragend = function(){  //拖拽结束触发

       this.style.background = &#39;&#39;;

     };
   }
   oDiv.ondragenter = function(ev){  //相当于onmouseover

     this.style.background = &#39;green&#39;;

     ev.preventDefault();  //阻止默认事件：元素就可以释放了

   };

   oDiv.ondragleave = function(){  //相当于onmouseout

     this.style.background = &#39;red&#39;;

   };

   oDiv.ondragover = function(ev){ //进入目标、离开目标之间，连续触发

     ev.preventDefault();  //阻止默认事件：元素就可以释放了

     document.title = iNow++;

   };

   oDiv.ondrop = function(ev){  //释放鼠标的时候触发

     this.style.background = &#39;red&#39;;

     alert(&quot;鼠标已经释放&quot;);

     ev.preventDefault();  //阻止默认事件：防止打开拖拽元素的url

   };
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;section-2&quot;&gt;参考文献&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/lee_magnum/article/details/17791701&quot;&gt;HTML5实战与剖析之原生拖拽(二拖拽事件dragstart、drag和dragend)&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Sat, 26 Mar 2016 15:51:21 +0800</pubDate>
        <link>http://didiaidada.win//2016/03/26/html5%E7%94%9F%E6%8B%96%E6%8B%BD.html</link>
        <guid isPermaLink="true">http://didiaidada.win//2016/03/26/html5%E7%94%9F%E6%8B%96%E6%8B%BD.html</guid>
        
        <category>JavaScript</category>
        
        
      </item>
    
  </channel>
</rss>
